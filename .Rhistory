# Calcular la precisión del modelo utilizando el coeficiente de correlación
correlation <- cor(predicted_labels, cbfvL_norm_1)
source("C:/Users/benja/Documents/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
# Cargar la biblioteca e1071
library(e1071)
library(pso)
setwd("C:/Users/benja/Documents/USACH/Memoria")
# Leer el archivo y almacenar los datos en un objeto llamado "data"
data <- read.table("Sujeto1.txt", header = TRUE)
# Almacenar las variables Time y MABP como vectores
time <- data$Time
mabp <- data$MABP
cbfv_L <- data$CBFV.L
# Aplicar la fórmula de normalización
mabp_norm <- (mabp - min(mabp)) / (max(mabp) - min(mabp))
cbfv_L_norm <- (cbfv_L - min(cbfv_L)) / (max(cbfv_L) - min(cbfv_L))
Data <- data.frame(cbind(time, mabp_norm, cbfv_L_norm))
# Obtener la longitud de los vectores de tiempo y MABP
n <- length(time)
# Obtener la mitad de la longitud de los vectores
n_half <- n/2
# Dividir los vectores en dos conjuntos deterministas
time_1 <- time[1:n_half]
mabp_norm_1 <- mabp_norm[1:n_half]
cbfvL_norm_1 <- cbfv_L_norm[1:n_half]
training_data <- data.frame(mabp_norm_1 = mabp_norm_1, cbfvL_norm_1 = cbfvL_norm_1)
time_2 <- time[(n_half+1):n]
mabp_norm_2 <- mabp_norm[(n_half+1):n]
cbfvL_norm_2 <- cbfv_L_norm[(n_half+1):n]
validation_data <- data.frame(time_1 = time_1, cbfvL_norm_1 = cbfvL_norm_1)
# Crear el modelo SVM regresiva utilizando un kernel lineal
svm_model <- svm(time_1 ~ mabp_norm_1, kernel = "radial", type = "nu-regression")
# Predecir las etiquetas de clase de los datos de prueba
predicted_labels <- predict(svm_model, newdata = validation_data)
# Calcular la precisión del modelo utilizando el coeficiente de correlación
correlation <- -cor(predicted_labels, cbfvL_norm_1)
# Cargar la biblioteca e1071
library(e1071)
library(pso)
setwd("C:/Users/benja/Documents/USACH/Memoria")
# Leer el archivo y almacenar los datos en un objeto llamado "data"
data <- read.table("Sujeto1.txt", header = TRUE)
# Almacenar las variables Time y MABP como vectores
time <- data$Time
mabp <- data$MABP
cbfv_L <- data$CBFV.L
# Aplicar la fórmula de normalización
mabp_norm <- (mabp - min(mabp)) / (max(mabp) - min(mabp))
cbfv_L_norm <- (cbfv_L - min(cbfv_L)) / (max(cbfv_L) - min(cbfv_L))
Data <- data.frame(cbind(time, mabp_norm, cbfv_L_norm))
# Obtener la longitud de los vectores de tiempo y MABP
n <- length(time)
# Obtener la mitad de la longitud de los vectores
n_half <- n/2
# Dividir los vectores en dos conjuntos deterministas
time_1 <- time[1:n_half]
mabp_norm_1 <- mabp_norm[1:n_half]
cbfvL_norm_1 <- cbfv_L_norm[1:n_half]
training_data <- data.frame(mabp_norm_1 = mabp_norm_1, cbfvL_norm_1 = cbfvL_norm_1)
time_2 <- time[(n_half+1):n]
mabp_norm_2 <- mabp_norm[(n_half+1):n]
cbfvL_norm_2 <- cbfv_L_norm[(n_half+1):n]
validation_data <- data.frame(time_1 = time_1, cbfvL_norm_1 = cbfvL_norm_1)
# Crear el modelo SVM regresiva utilizando un kernel lineal
svm_model <- svm(time_1 ~ mabp_norm_1, kernel = "radial", type = "nu-regression")
# Predecir las etiquetas de clase de los datos de prueba
predicted_labels <- predict(svm_model, newdata = validation_data)
# Calcular la precisión del modelo utilizando el coeficiente de correlación
correlation <- cor(predicted_labels, cbfvL_norm_1)
source("C:/Users/benja/Documents/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("C:/Users/benja/Documents/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("C:/Users/benja/Documents/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("C:/Users/benja/Documents/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("C:/Users/benja/Documents/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("C:/Users/benja/Documents/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("C:/Users/benja/Documents/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("C:/Users/benja/Documents/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("C:/Users/benja/Documents/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("C:/Users/benja/Documents/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("C:/Users/benja/Documents/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("C:/Users/benja/Documents/USACH/Memoria/highCorrelationPAM.R", echo=TRUE)
# Cargar la biblioteca e1071
library(e1071)
library(pso)
setwd("C:/Users/benja/Documents/USACH/Memoria")
# Leer el archivo y almacenar los datos en un objeto llamado "data"
data <- read.table("Sujeto1.txt", header = TRUE)
# Almacenar las variables Time y MABP como vectores
time <- data$Time
mabp <- data$MABP
cbfv_L <- data$CBFV.L
# Aplicar la fórmula de normalización
mabp_norm <- (mabp - min(mabp)) / (max(mabp) - min(mabp))
cbfv_L_norm <- (cbfv_L - min(cbfv_L)) / (max(cbfv_L) - min(cbfv_L))
Data <- data.frame(cbind(time, mabp_norm, cbfv_L_norm))
# Obtener la longitud de los vectores de tiempo y MABP
n <- length(time)
# Obtener la mitad de la longitud de los vectores
n_half <- n/2
# Dividir los vectores en dos conjuntos deterministas
time_1 <- time[1:n_half]
mabp_norm_1 <- mabp_norm[1:n_half]
cbfvL_norm_1 <- cbfv_L_norm[1:n_half]
training_data <- data.frame(mabp_norm_1 = mabp_norm_1, cbfvL_norm_1 = cbfvL_norm_1)
time_2 <- time[(n_half+1):n]
mabp_norm_2 <- mabp_norm[(n_half+1):n]
cbfvL_norm_2 <- cbfv_L_norm[(n_half+1):n]
validation_data <- data.frame(time_1 = time_1, cbfvL_norm_1 = cbfvL_norm_1)
# Crear el modelo SVM regresiva utilizando un kernel lineal
svm_model <- svm(mabp_norm_1 ~ time_1 + cbfvL_norm_1, kernel = "radial", type = "nu-regression")
# Cargar la biblioteca e1071
library(e1071)
library(pso)
setwd("C:/Users/benja/Documents/USACH/Memoria")
# Leer el archivo y almacenar los datos en un objeto llamado "data"
data <- read.table("Sujeto1.txt", header = TRUE)
# Almacenar las variables Time y MABP como vectores
time <- data$Time
mabp <- data$MABP
cbfv_L <- data$CBFV.L
# Aplicar la fórmula de normalización
mabp_norm <- (mabp - min(mabp)) / (max(mabp) - min(mabp))
cbfv_L_norm <- (cbfv_L - min(cbfv_L)) / (max(cbfv_L) - min(cbfv_L))
Data <- data.frame(cbind(time, mabp_norm, cbfv_L_norm))
# Obtener la longitud de los vectores de tiempo y MABP
n <- length(time)
# Obtener la mitad de la longitud de los vectores
n_half <- n/2
# Dividir los vectores en dos conjuntos deterministas
time_1 <- time[1:n_half]
mabp_norm_1 <- mabp_norm[1:n_half]
cbfvL_norm_1 <- cbfv_L_norm[1:n_half]
training_data <- data.frame(mabp_norm_1 = mabp_norm_1, cbfvL_norm_1 = cbfvL_norm_1)
time_2 <- time[(n_half+1):n]
mabp_norm_2 <- mabp_norm[(n_half+1):n]
cbfvL_norm_2 <- cbfv_L_norm[(n_half+1):n]
validation_data <- data.frame(time_1 = time_1, cbfvL_norm_1 = cbfvL_norm_1)
# Crear el modelo SVM regresiva utilizando un kernel lineal
svm_model <- svm(cbfvL_norm_1 ~ time_1 + mabp_norm_1, kernel = "radial", type = "nu-regression")
# Cargar la biblioteca e1071
library(e1071)
library(pso)
setwd("C:/Users/benja/Documents/USACH/Memoria")
# Leer el archivo y almacenar los datos en un objeto llamado "data"
data <- read.table("Sujeto1.txt", header = TRUE)
# Almacenar las variables Time y MABP como vectores
time <- data$Time
mabp <- data$MABP
cbfv_L <- data$CBFV.L
# Aplicar la fórmula de normalización
mabp_norm <- (mabp - min(mabp)) / (max(mabp) - min(mabp))
cbfv_L_norm <- (cbfv_L - min(cbfv_L)) / (max(cbfv_L) - min(cbfv_L))
Data <- data.frame(cbind(time, mabp_norm, cbfv_L_norm))
# Obtener la longitud de los vectores de tiempo y MABP
n <- length(time)
# Obtener la mitad de la longitud de los vectores
n_half <- n/2
# Dividir los vectores en dos conjuntos deterministas
time_1 <- time[1:n_half]
mabp_norm_1 <- mabp_norm[1:n_half]
cbfvL_norm_1 <- cbfv_L_norm[1:n_half]
training_data <- data.frame(time_1 = time_1, mabp_norm_1 = mabp_norm_1, cbfvL_norm_1 = cbfvL_norm_1)
time_2 <- time[(n_half+1):n]
mabp_norm_2 <- mabp_norm[(n_half+1):n]
cbfvL_norm_2 <- cbfv_L_norm[(n_half+1):n]
validation_data <- data.frame(time_2 = time_2, cbfvL_norm_2 = cbfvL_norm_2)
# Crear el modelo SVM regresiva utilizando un kernel lineal
svm_model <- svm(cbfvL_norm_1 ~ time_1 + mabp_norm_1, data = training_data, kernel = "radial", type = "nu-regression")
# Predecir las etiquetas de clase de los datos de prueba
predicted_labels <- predict(svm_model, mabp_norm_2 = mabp_norm_2, newdata = validation_data)
# Calcular la precisión del modelo utilizando el coeficiente de correlación
correlation <- cor(predicted_labels, cbfvL_norm_1)
plot(time_1, predicted_labels)
plot(time_1, cbfvL_norm_1)
plot(time_1, predicted_labels, type="l")
plot(time_1, cbfvL_norm_1, type="l")
# Cargar la biblioteca e1071
library(e1071)
library(pso)
setwd("C:/Users/benja/Documents/USACH/Memoria")
# Leer el archivo y almacenar los datos en un objeto llamado "data"
data <- read.table("Sujeto1.txt", header = TRUE)
# Almacenar las variables Time y MABP como vectores
time <- data$Time
mabp <- data$MABP
cbfv_L <- data$CBFV.L
# Aplicar la fórmula de normalización
mabp_norm <- (mabp - min(mabp)) / (max(mabp) - min(mabp))
cbfv_L_norm <- (cbfv_L - min(cbfv_L)) / (max(cbfv_L) - min(cbfv_L))
Data <- data.frame(cbind(time, mabp_norm, cbfv_L_norm))
# Obtener la longitud de los vectores de tiempo y MABP
n <- length(time)
# Obtener la mitad de la longitud de los vectores
n_half <- n/2
# Dividir los vectores en dos conjuntos deterministas
time_1 <- time[1:n_half]
mabp_norm_1 <- mabp_norm[1:n_half]
cbfvL_norm_1 <- cbfv_L_norm[1:n_half]
training_data <- data.frame(time_1 = time_1, mabp_norm_1 = mabp_norm_1, cbfvL_norm_1 = cbfvL_norm_1)
time_2 <- time[(n_half+1):n]
mabp_norm_2 <- mabp_norm[(n_half+1):n]
cbfvL_norm_2 <- cbfv_L_norm[(n_half+1):n]
validation_data <- data.frame(time_2 = time_2, cbfvL_norm_2 = cbfvL_norm_2)
# Crear el modelo SVM regresiva utilizando un kernel lineal
svm_model <- svm(cbfvL_norm_1 ~ time_1 + mabp_norm_1, data = training_data, kernel = "linear", type = "nu-regression")
# Predecir las etiquetas de clase de los datos de prueba
predicted_labels <- predict(svm_model, mabp_norm_2 = mabp_norm_2, newdata = validation_data)
# Calcular la precisión del modelo utilizando el coeficiente de correlación
correlation <- cor(predicted_labels, cbfvL_norm_1)
plot(time_1, predicted_labels, type="l")
plot(time_1, cbfvL_norm_1, type="l")
# Cargar la biblioteca e1071
library(e1071)
library(pso)
setwd("C:/Users/benja/Documents/USACH/Memoria")
# Leer el archivo y almacenar los datos en un objeto llamado "data"
data <- read.table("Sujeto1.txt", header = TRUE)
# Almacenar las variables Time y MABP como vectores
time <- data$Time
mabp <- data$MABP
cbfv_L <- data$CBFV.L
# Aplicar la fórmula de normalización
mabp_norm <- (mabp - min(mabp)) / (max(mabp) - min(mabp))
cbfv_L_norm <- (cbfv_L - min(cbfv_L)) / (max(cbfv_L) - min(cbfv_L))
Data <- data.frame(cbind(time, mabp_norm, cbfv_L_norm))
# Obtener la longitud de los vectores de tiempo y MABP
n <- length(time)
# Obtener la mitad de la longitud de los vectores
n_half <- n/2
# Dividir los vectores en dos conjuntos deterministas
time_1 <- time[1:n_half]
mabp_norm_1 <- mabp_norm[1:n_half]
cbfvL_norm_1 <- cbfv_L_norm[1:n_half]
training_data <- data.frame(time_1 = time_1, mabp_norm_1 = mabp_norm_1, cbfvL_norm_1 = cbfvL_norm_1)
time_2 <- time[(n_half+1):n]
mabp_norm_2 <- mabp_norm[(n_half+1):n]
cbfvL_norm_2 <- cbfv_L_norm[(n_half+1):n]
validation_data <- data.frame(time_2 = time_2, mabp_norm_2 = mabp_norm_2, cbfvL_norm_2 = cbfvL_norm_2)
# Crear el modelo SVM regresiva utilizando un kernel lineal
svm_model <- svm(cbfvL_norm_1 ~ time_1 + mabp_norm_1, data = training_data, kernel = "linear", type = "nu-regression")
# Predecir las etiquetas de clase de los datos de prueba
predicted_labels <- predict(svm_model, newdata = validation_data)
# Calcular la precisión del modelo utilizando el coeficiente de correlación
correlation <- cor(predicted_labels, cbfvL_norm_1)
plot(time_1, predicted_labels, type="l")
plot(time_1, cbfvL_norm_1, type="l")
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
plot(pressure_step)
plot(pressure_step_smooth)
pressure <- c(rep(0, 50), rep(-0.5, 100)) # escalón invertido de presión
pressure_step <- butter(2, 0.2, type = "low", fs = 2) # filtro Butterworth de segundo orden
pressure_step_smooth <- filter(pressure_step, -pressure) # aplicar filtro al escalón de presión negativo
plot(pressure_step_smooth)
pressure <- c(rep(0, 50), rep(-0.5, 100)) # escalón invertido de presión
pressure_step <- butter(2, 0.2, type = "low", fs = 2) # filtro Butterworth de segundo orden
pressure_step_smooth <- filter(pressure_step, pressure) # aplicar filtro al escalón de presión negativo
plot(pressure_step_smooth)
pressure <- c(rep(0, 50), rep(-0.5, 100)) # escalón invertido de presión
pressure_step <- butter(2, 0.2, type = "low", fs = 2) # filtro Butterworth de segundo orden
pressure_step_smooth <- -filter(pressure_step, pressure) # aplicar filtro al escalón de presión negativo
plot(pressure_step_smooth)
pressure <- c(rep(1, 50), rep(0, 100)) # escalón invertido de presión
pressure_step <- butter(2, 0.2, type = "low", fs = 2) # filtro Butterworth de segundo orden
pressure_step_smooth <- filter(pressure_step, pressure) # aplicar filtro al escalón de presión negativo
plot(pressure_step_smooth)
pressure <- c(rep(1, 50), rep(0, 100)) # escalón invertido de presión
pressure_step <- butter(2, 0.2, type = "low", fs = 2) # filtro Butterworth de segundo orden
pressure_step_smooth <- -filter(pressure_step, -pressure) # aplicar filtro al escalón de presión negativo
plot(pressure_step_smooth)
pressure <- c(rep(1, 50), rep(0, 100)) # escalón invertido de presión
pressure_step <- butter(2, 0.2, type = "low", fs = 1) # filtro Butterworth de segundo orden
pressure_step_smooth <- filter(pressure_step, pressure) # aplicar filtro al escalón de presión negativo
plot(pressure_step_smooth)
pressure <- c(rep(1, 50), rep(0, 100)) # escalón invertido de presión
pressure_step <- butter(2, 0.2, type = "low", fs = 2) # filtro Butterworth de segundo orden
pressure_step_smooth <- filter(pressure_step, pressure) # aplicar filtro al escalón de presión negativo
plot(pressure_step_smooth)
pressure <- c(rep(1, 50), rep(0, 100)) # escalón invertido de presión
pressure_step <- butter(2, 0.2, type = "stop", fs = 2) # filtro Butterworth de segundo orden
pressure_step_smooth <- filter(pressure_step, pressure) # aplicar filtro al escalón de presión negativo
plot(pressure_step_smooth)
pressure <- c(rep(1, 50), rep(0, 100)) # escalón invertido de presión
pressure_step <- butter(2, 0.2, type = "pass", fs = 2) # filtro Butterworth de segundo orden
pressure_step_smooth <- filter(pressure_step, pressure) # aplicar filtro al escalón de presión negativo
plot(pressure_step_smooth)
pressure <- c(rep(1, 50), rep(0, 100)) # escalón invertido de presión
pressure_step <- butter(2, 0.2, type = "high", fs = 2) # filtro Butterworth de segundo orden
pressure_step_smooth <- filter(pressure_step, pressure) # aplicar filtro al escalón de presión negativo
plot(pressure_step_smooth)
pressure <- c(rep(1, 50), rep(0, 100)) # escalón invertido de presión
pressure_step <- butter(2, 0.2, type = "low", fs = 2) # filtro Butterworth de segundo orden
pressure_step_smooth <- filter(pressure_step, pressure) # aplicar filtro al escalón de presión negativo
plot(pressure_step_smooth)
pressure <- c(rep(1, 20), rep(0, 130)) # escalón invertido de presión
pressure_step <- butter(2, 0.2, type = "low", fs = 2) # filtro Butterworth de segundo orden
pressure_step_smooth <- filter(pressure_step, pressure) # aplicar filtro al escalón de presión negativo
plot(pressure_step_smooth)
pressure <- c(rep(1, 50), rep(0, 100)) # escalón invertido de presión
pressure_step <- butter(2, 0.2, type = "low", fs = 2) # filtro Butterworth de segundo orden
pressure_step_smooth <- filter(pressure_step, pressure) # aplicar filtro al escalón de presión negativo
plot(pressure_step_smooth)
pressure <- c(rep(0, 50), rep(1, 100)) # escalón invertido de presión
pressure_step <- butter(2, 0.2, type = "low", fs = 2) # filtro Butterworth de segundo orden
pressure_step_smooth <- filter(pressure_step, pressure) # aplicar filtro al escalón de presión negativo
plot(pressure_step_smooth)
pressure <- c(rep(0, 50), rep(1, 100)) # escalón invertido de presión
pressure_step <- butter(2, 0.2, type = "low", fs = 2) # filtro Butterworth de segundo orden
pressure_step_smooth <- filter(pressure_step, -pressure) # aplicar filtro al escalón de presión negativo
plot(pressure_step_smooth)
pressure <- c(rep(0, 50), rep(1, 100)) # escalón invertido de presión
pressure_step <- butter(2, 0.2, type = "low", fs = 2) # filtro Butterworth de segundo orden
pressure_step_smooth <- -filter(pressure_step, -pressure) # aplicar filtro al escalón de presión negativo
plot(pressure_step_smooth)
pressure <- c(rep(0, 50), rep(1, 100)) # escalón invertido de presión
pressure_step <- butter(2, 0.2, type = "low", fs = 2) # filtro Butterworth de segundo orden
pressure_step_smooth <- filter(pressure_step, -pressure) # aplicar filtro al escalón de presión negativo
plot(pressure_step_smooth)
pressure <- c(rep(0, 50), rep(1, 100)) # escalón invertido de presión
pressure_step <- butter(2, 0.2, type = "low", fs = 2) # filtro Butterworth de segundo orden
pressure_step_smooth <- filter(pressure_step, -pressure) + 1 # aplicar filtro al escalón de presión negativo
plot(pressure_step_smooth)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
# Cargar la biblioteca e1071
library(e1071)
library(pso)
setwd("C:/Users/benja/Documents/USACH/Memoria")
# Leer el archivo y almacenar los datos en un objeto llamado "data"
data <- read.table("Sujeto1.txt", header = TRUE)
# Almacenar las variables Time y MABP como vectores
time <- data$Time
mabp <- data$MABP
cbfv_L <- data$CBFV.L
# Aplicar la fórmula de normalización
mabp_norm <- (mabp - min(mabp)) / (max(mabp) - min(mabp))
cbfv_L_norm <- (cbfv_L - min(cbfv_L)) / (max(cbfv_L) - min(cbfv_L))
Data <- data.frame(cbind(time, mabp_norm, cbfv_L_norm))
# Obtener la longitud de los vectores de tiempo y MABP
n <- length(time)
# Obtener la mitad de la longitud de los vectores
n_half <- n/2
# Dividir los vectores en dos conjuntos deterministas
time_1 <- time[1:n_half]
mabp_norm_1 <- mabp_norm[1:n_half]
cbfvL_norm_1 <- cbfv_L_norm[1:n_half]
plot(time_1, cbfvL_norm_1, type="l")
training_data <- data.frame(time_1 = time_1, mabp_norm_1 = mabp_norm_1, cbfvL_norm_1 = cbfvL_norm_1)
time_2 <- time[(n_half+1):n]
mabp_norm_2 <- mabp_norm[(n_half+1):n]
cbfvL_norm_2 <- cbfv_L_norm[(n_half+1):n]
validation_data <- data.frame(time_2 = time_2, mabp_norm_2 = mabp_norm_2, cbfvL_norm_2 = cbfvL_norm_2)
# Crear el modelo SVM regresiva utilizando un kernel lineal
svm_model <- svm(cbfvL_norm_1 ~ time_1 + mabp_norm_1, data = training_data, kernel = "linear", type = "nu-regression")
# Predecir las etiquetas de clase de los datos de prueba
predicted_labels <- predict(svm_model, newdata = validation_data)
points(time_1, predicted_labels, type="l", color="blue")
# Calcular la precisión del modelo utilizando el coeficiente de correlación
correlation <- cor(predicted_labels, cbfvL_norm_1)
points(time_1, predicted_labels, type="l", col="blue")
# Cargar la biblioteca e1071
library(e1071)
library(pso)
setwd("C:/Users/benja/Documents/USACH/Memoria")
# Leer el archivo y almacenar los datos en un objeto llamado "data"
data <- read.table("Sujeto1.txt", header = TRUE)
# Almacenar las variables Time y MABP como vectores
time <- data$Time
mabp <- data$MABP
cbfv_L <- data$CBFV.L
# Aplicar la fórmula de normalización
mabp_norm <- (mabp - min(mabp)) / (max(mabp) - min(mabp))
cbfv_L_norm <- (cbfv_L - min(cbfv_L)) / (max(cbfv_L) - min(cbfv_L))
Data <- data.frame(cbind(time, mabp_norm, cbfv_L_norm))
# Obtener la longitud de los vectores de tiempo y MABP
n <- length(time)
# Obtener la mitad de la longitud de los vectores
n_half <- n/2
# Dividir los vectores en dos conjuntos deterministas
time_1 <- time[1:n_half]
mabp_norm_1 <- mabp_norm[1:n_half]
cbfvL_norm_1 <- cbfv_L_norm[1:n_half]
plot(time_1, cbfvL_norm_1, type="l")
training_data <- data.frame(time_1 = time_1, mabp_norm_1 = mabp_norm_1, cbfvL_norm_1 = cbfvL_norm_1)
time_2 <- time[(n_half+1):n]
mabp_norm_2 <- mabp_norm[(n_half+1):n]
cbfvL_norm_2 <- cbfv_L_norm[(n_half+1):n]
validation_data <- data.frame(time_2 = time_2, mabp_norm_2 = mabp_norm_2, cbfvL_norm_2 = cbfvL_norm_2)
# Crear el modelo SVM regresiva utilizando un kernel lineal
svm_model <- svm(cbfvL_norm_1 ~ time_1 + mabp_norm_1, data = training_data, kernel = "linear", type = "nu-regression")
# Predecir las etiquetas de clase de los datos de prueba
predicted_labels <- predict(svm_model, newdata = validation_data)
points(time_1, predicted_labels, type="l", col="blue")
# Calcular la precisión del modelo utilizando el coeficiente de correlación
correlation <- cor(predicted_labels, cbfvL_norm_1)
pressure <- c(rep(1, 50), rep(0, 100)) # escalón invertido de presión
pressure_step <- butter(2, 0.2, type = "low", fs = 2) # filtro Butterworth de segundo orden
pressure_step_smooth <- filter(pressure_step, pressure) # + 1 # aplicar filtro al escalón de presión negativo
points(pressure, type="l", col="red")
points(pressure_step_smooth, type="l", col="red")
# Cargar la biblioteca e1071
library(e1071)
library(pso)
setwd("C:/Users/benja/Documents/USACH/Memoria")
# Leer el archivo y almacenar los datos en un objeto llamado "data"
data <- read.table("Sujeto1.txt", header = TRUE)
# Almacenar las variables Time y MABP como vectores
time <- data$Time
mabp <- data$MABP
cbfv_L <- data$CBFV.L
# Aplicar la fórmula de normalización
mabp_norm <- (mabp - min(mabp)) / (max(mabp) - min(mabp))
cbfv_L_norm <- (cbfv_L - min(cbfv_L)) / (max(cbfv_L) - min(cbfv_L))
Data <- data.frame(cbind(time, mabp_norm, cbfv_L_norm))
# Obtener la longitud de los vectores de tiempo y MABP
n <- length(time)
# Obtener la mitad de la longitud de los vectores
n_half <- n/2
# Dividir los vectores en dos conjuntos deterministas
time_1 <- time[1:n_half]
mabp_norm_1 <- mabp_norm[1:n_half]
cbfvL_norm_1 <- cbfv_L_norm[1:n_half]
plot(time_1, cbfvL_norm_1, type="l")
training_data <- data.frame(time_1 = time_1, mabp_norm_1 = mabp_norm_1, cbfvL_norm_1 = cbfvL_norm_1)
time_2 <- time[(n_half+1):n]
mabp_norm_2 <- mabp_norm[(n_half+1):n]
cbfvL_norm_2 <- cbfv_L_norm[(n_half+1):n]
validation_data <- data.frame(time_2 = time_2, mabp_norm_2 = mabp_norm_2, cbfvL_norm_2 = cbfvL_norm_2)
# Crear el modelo SVM regresiva utilizando un kernel lineal
svm_model <- svm(cbfvL_norm_1 ~ time_1 + mabp_norm_1, data = training_data, kernel = "linear", type = "nu-regression")
# Predecir las etiquetas de clase de los datos de prueba
predicted_labels <- predict(svm_model, newdata = validation_data)
points(time_1, predicted_labels, type="l", col="blue")
# Calcular la precisión del modelo utilizando el coeficiente de correlación
correlation <- cor(predicted_labels, cbfvL_norm_1)
pressure <- c(rep(1, 50), rep(0, 100)) # escalón invertido de presión
pressure_step <- butter(2, 0.2, type = "low", fs = 2) # filtro Butterworth de segundo orden
pressure_step_smooth <- filter(pressure_step, pressure) # + 1 # aplicar filtro al escalón de presión negativo
points(pressure_step_smooth, type="l", col="red")
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
pressure <- c(rep(1, 50), rep(0, 250)) # escalón invertido de presión
pressure_step <- butter(2, 0.2, type = "low", fs = 2) # filtro Butterworth de segundo orden
time_pressure <- seq(0, 150, 0.5)
pressure_filtered <- filter(pressure, pressure_step)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
View(validation_data)
test <- data.frame(time = time_1, pressure = pressure_step_smooth)
View(test)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
source("~/USACH/Memoria/PAM_to_VFSC_model.R", echo=TRUE)
