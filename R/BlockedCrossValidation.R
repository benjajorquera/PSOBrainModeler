#' Generate Data Partitions for Blocked K-fold Cross-Validation
#'
#' @param data Dataframe. The dataset to partition.
#' @param num_blocks (Optional) Integer. The number of blocks to divide the
#'  dataset into. Defaults to 5.
#' @param validation_size (Optional) Numeric (between 0 and 1). Proportion of
#'  data to be used
#'  for validation in each partition. Defaults to 0.2.
#'
#' @return A list of partitions, each containing a training set and a validation
#'  set.
#'
#' @examples
#' data <- data.frame(x = 1:100, y = 101:200)
#' partitions <- blocked_cv(data, num_blocks = 5, validation_size = 0.2)
#'
#' @export
#'
blocked_cv <-
  function(data,
           num_blocks = 5,
           validation_size = 0.2) {
    # Validation
    stopifnot(is.data.frame(data))
    
    # Compute the validation length based on the total rows and desired size
    validation_length <- round(nrow(data) * validation_size)
    
    # Generate partitions
    data_partitions <- lapply(1:num_blocks, function(block) {
      # Define start index for each block
      start_idx <- (block - 1) * validation_length + 1
      
      # Determine end index based on block number
      end_idx <-
        if (block == num_blocks)
          nrow(data)
      else
        block * validation_length
      
      # Extract validation data based on indices
      validation_data <- data[start_idx:end_idx, ]
      
      # The training data is the remaining data after excluding the
      # validation data
      training_data <- data[-(start_idx:end_idx), ]
      
      list(training = training_data, validation = validation_data)
    })
    
    return(data_partitions)
  }


#' Cross-Validate Partition for SVR Model
#'
#' This function performs cross-validation on the given data partitions using a
#' Support Vector Regression (SVR) model. It returns the average correlation
#' and mean squared error over the partitions.
#'
#' @param cost Numeric. The cost parameter for the SVR model.
#' @param nu Numeric. The nu parameter for the SVR model.
#' @param gamma (Optional) Numeric. The gamma parameter for the SVR model.
#'  Defaults to NULL.
#' @param data_partitions List of dataframes. The data partitions to use for
#'  training and validation.
#' @param bcv_folds (Optional) Numeric. Number of cross-validation folds.
#'  Defaults to 5.
#' @param signal_norm_names Character vector. Normalized signal column names.
#' @param predictors_norm_names Character vector. Normalized predictor column
#'  names.
#' @param lagged_cols Character vector. Names of lagged columns.
#' @param combined_col_lags Numeric vector indicating the combined lags of the
#'  predictor and response columns.
#' @param vsvr_response Character. Response column name for the SVR model.
#' @param vsvr_tolerance (Optional) Numeric. Tolerance parameter for the SVR
#'  model. Defaults to 1.
#' @param silent (Optional) Logical. Determines if the function should run
#'  silently. Defaults to TRUE.
#' @param training_list_name (Optional) Character. Name of the training data
#'  list element. Defaults to "training".
#' @param validation_list_name (Optional) Character. Name of the validation
#'  data list element. Defaults to "validation".
#' @param svm_cache_size Numeric. Cache size for the SVR model. Defaults to 100.
#' @param generate_response_predictions_cv Logical. Controls generation of
#'  response predictions. Defaults to FALSE.
#' @param col_lags (Optional) Numeric/Integer vector. Specifies column lags for
#'  response prediction.
#' @param response_lags (Optional) Numeric/Integer. Lags for the response
#'  variable.
#' @param initial_column_values (Optional) Numeric vector/list. Initial values
#'  for each column.
#' @param prediction_initial_value (Optional) Numeric. Initial value for
#'  prediction.
#' @param data_env_list (Optional) List. Additional data structures for
#'  response prediction.
#'
#' @return A list containing various metrics and information from the
#'  cross-validation process:
#' \itemize{
#'   \item \code{avg_cor}: Average correlation across all folds.
#'   \item \code{avg_error}: Average mean squared error across all folds.
#'   \item \code{na_count}: Count of NA values encountered during computation.
#'   \item \code{warnings}: Count of warnings generated by the SVR model.
#'   \item \code{cv_predictions}: List of prediction-related data if
#'    \code{generate_response_predictions_cv} is TRUE.
#'   \item \code{time}: The time taken to execute the cross-validation process,
#'    measured in seconds.
#' }
#'
#' @examples
#' data_partition_sample <- list(list(training = data.frame(feature1 = rnorm(20),
#' feature2 = rnorm(20), feature1_1 = rnorm(20)), validation = data.frame(
#' feature1 = rnorm(20), feature2 = rnorm(20), feature1_1 = rnorm(20))))
#' cross_validate_partition(cost = 1, nu = 0.5, gamma = NULL,
#'  data_partitions = data_partition_sample,
#' bcv_folds = 1, signal_norm_names = c("feature1", "feature2"),
#' predictors_norm_names = c("feature1"), lagged_cols = c("feature1"),
#'  combined_col_lags = c(1),
#' vsvr_response = "feature2", vsvr_tolerance = 1)
#'
#' @importFrom stats sd cor
#' @importFrom utils modifyList
#' @export
#'
cross_validate_partition <-
  function(cost,
           nu,
           gamma = NULL,
           data_partitions,
           bcv_folds = 5,
           signal_norm_names,
           predictors_norm_names,
           lagged_cols,
           combined_col_lags,
           vsvr_response,
           vsvr_tolerance = 1,
           silent = TRUE,
           training_list_name = "training",
           validation_list_name = "validation",
           svm_cache_size = 100,
           generate_response_predictions_cv = FALSE,
           col_lags = NULL,
           response_lags = NULL,
           initial_column_values = NULL,
           prediction_initial_value = NULL,
           data_env_list = NULL) {
    time <- Sys.time()
    
    cors <- numeric(bcv_folds)
    errors <- numeric(bcv_folds)
    
    na_count <- 0
    svm_warnings <- 0
    
    # Common arguments for generate_time_series_data
    common_args <- list(
      data_cols = signal_norm_names,
      predictor_cols = predictors_norm_names,
      lagged_cols = lagged_cols,
      lag_values = combined_col_lags,
      vsvr_response = vsvr_response
    )
    
    cv_predictions <- list()
    
    for (df_list in seq_len(bcv_folds)) {
      # Prepare data for validation
      args_validation <-
        utils::modifyList(list(input_df = data_partitions[[df_list]][[validation_list_name]],
                               is_training = FALSE),
                          common_args)
      new_data_validation <-
        do.call(generate_time_series_data, args_validation)
      
      # Prepare data for training
      args_training <-
        utils::modifyList(list(input_df = data_partitions[[df_list]][[training_list_name]],
                               is_training = TRUE),
                          common_args)
      data_partitions_training <-
        do.call(generate_time_series_data, args_training)
      
      # Train SVR model
      svr_model <-
        vsvr_model(
          data = data_partitions_training,
          response_var = vsvr_response,
          cost = cost,
          nu = nu,
          gamma = gamma,
          tolerance = vsvr_tolerance,
          cache_size = svm_cache_size
        )
      
      svm_warnings <-
        svm_warnings + svr_model$max_iterations_warnings
      
      # Make predictions
      predictions <-
        predict(svr_model$svm_model, new_data_validation)
      
      if (stats::sd(predictions) == 0) {
        if (!silent) {
          message(
            "\nSTANDARD DEVIATION OF 'PREDICTIONS' IS ZERO: SVM TOLERANCE IS TOO HIGH FOR NUMBER OF LAGS USED"
          )
        }
        cors[df_list] <- NA
        errors[df_list] <- NA
        na_count <- na_count + 1
        next
      }
      
      if (generate_response_predictions_cv) {
        response_params <- list(
          data = data_partitions_training,
          col_lags = col_lags,
          response_lags = response_lags,
          initial_column_values = initial_column_values,
          prediction_initial_value = prediction_initial_value,
          cost = cost,
          nu = nu,
          gamma = gamma,
          data_list = data_env_list,
          included_model = svr_model,
          vsvr_response = vsvr_response,
          silent = silent
        )
        
        response_data <-
          generate_and_evaluate_response_cv(response_params)
        cv_predictions <-
          append(cv_predictions, list(response_data))
      }
      
      target_vals <-
        data_partitions[[df_list]][[validation_list_name]][[vsvr_response]]
      
      # Compute and save correlation and MSE
      cors[df_list] <- stats::cor(predictions, target_vals)
      errors[df_list] <-
        sqrt(mean((target_vals - predictions) ^ 2))
    }
    
    return(
      list(
        avg_cor = mean(cors, na.rm = TRUE),
        avg_error = mean(errors, na.rm = TRUE),
        na_count = na_count,
        warnings = svm_warnings,
        cv_predictions = cv_predictions,
        time = Sys.time() - time
      )
    )
  }

#' Generate and Evaluate Response for Cross-Validation
#'
#' This function generates response predictions, evaluates signal quality, and
#' applies an advanced filter as part of the cross-validation process in an SVR
#' model. It is specifically designed to be used within the
#' `cross_validate_partition` function.
#'
#' @param params A list containing all necessary parameters for generating and
#'  evaluating the response.
#' The list should include:
#' \itemize{
#'   \item \code{data}: The training data as a dataframe.
#'   \item \code{col_lags}: Numeric or integer vector specifying the lags for
#'    each column.
#'   \item \code{response_lags}: Numeric or integer for the response variable
#'    lags.
#'   \item \code{initial_column_values}: Initial values for each column as a
#'    numeric vector or list.
#'   \item \code{prediction_initial_value}: Initial value for prediction.
#'   \item \code{cost}: The cost parameter for the SVR model.
#'   \item \code{nu}: The nu parameter for the SVR model.
#'   \item \code{gamma}: The gamma parameter for the SVR model.
#'   \item \code{data_list}: Additional data structures or context for the
#'    response prediction.
#'   \item \code{included_model}: The trained SVR model.
#'   \item \code{vsvr_response}: The response column name for the SVR model.
#'   \item \code{silent}: Logical flag to run the function silently.
#' }
#'
#' @return A list containing the generated response signal, associated warnings,
#'  support vectors count, basic filter score, and advanced score along with
#'  its results.
#'
#' @examples
#' \dontrun{
#'   generate_and_evaluate_response_cv(...)
#' }
#'
#' @export
#'
generate_and_evaluate_response_cv <- function(params) {
  response_signal <- generate_signal_response_predictions_helper(
    data = params$data,
    col_lags = params$col_lags,
    response_lags = params$response_lags,
    initial_column_values = params$initial_column_values,
    prediction_initial_value = params$prediction_initial_value,
    cost = params$cost,
    nu = params$nu,
    gamma = params$gamma,
    data_list = params$data_list,
    included_model = params$included_model
  )
  
  signal_score <-
    evaluate_signal_quality(
      response_signal$predicted_values[[params$vsvr_response]],
      silent = params$silent,
      max_diff_threshold = params$data_list$response_max_diff_threshold
    )
  
  if (signal_score$result == "TEST PASSED") {
    advanced_score <-
      advanced_filter(response_signal$predicted_values[[params$vsvr_response]])
  }
  else {
    advanced_score <- list(score = 0, results = NULL)
  }
  
  
  response_data <- c(
    response_signal = list(response_signal$predicted_values[[params$vsvr_response]]),
    response_predictions_warnings = response_signal$warnings,
    support_vectors = response_signal$model$tot.nSV,
    basic_filter = list(signal_score),
    advanced_score = advanced_score$score,
    advanced_score_results = advanced_score$results
  )
  
  return(response_data)
}
